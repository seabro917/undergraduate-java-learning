随机数保存的那个代码从网上下载的课本案例中给了课后思考题的代码
为了实现对于表格中随机数的计算，直接继承了原来第一次写出来的框架，之后再进行一定的添加即可。
并且注意，再进行事件监听器注册和事件响应时，一定要在新写的子类的actionPerformed方法中第一句写super.actionPerformed(ev);
如果没有这一句，则所有在父类中已经实现了的事件响应会被覆盖。

还有就是如果一个变量或者组件或者其他的（比如这个代码中用于展示出计算得到的最大值最小值以及平均值的JTextField）在类的方法中也要被调用，则最好
把这个变量或者组件写在类的最开始的成员变量中，而不是在方法中声明为局部变量。

▲关于管道流的问题 
1、PipedInputStream运用的是一个1024字节固定大小的循环缓冲区。写入PipedOutputStream的数据实际上保存到对应的 PipedInputStream的
内部缓冲区。
★“Listing 2示范了这个问题。这个程序用一个线程交替地读取PipedInputStream和写入PipedOutputStream。每次调用write()向 PipedInputStream的缓冲
区写入20字节，每次调用read()只从缓冲区读取并删除10个字节。内部缓冲区最终会被写满，导致写操作阻塞。由于我们用同一个线程执行读、写操作，一旦
写操作被阻塞，就不能再从PipedInputStream读取数据。”
(因为这里执行对管道缓冲区写入数据和读取数据的线程为同一个，每次写入20字节再读取10字节当然就是线程run一次就再缓存区留下了10字节，当缓存区
的1024字节区域被存放满之后，由于只有这一个线程在运行，写不进去，也就自然执行不到之后run之中从缓存区读取数据的代码，所以就会线程堵塞在这里。)
★“只要把读/写操作分开到不同的线程，Listing 2的问题就可以轻松地解决。Listing 3是Listing 2经过修改后的版本，它在一个单独的线程中执行写入
PipedOutputStream的操作（和读取线程不同的线程）。为证明一次写入的数据可以超过 1024字节，我们让写操作线程每次调用PipedOutputStream的
write()方法时写入2000字节。那么，在 startWriterThread()方法中创建的线程是否会阻塞呢？按照Java运行时线程调度机制，它当然会阻塞。写操作在阻塞
之前实际上最多只能写入1024字节的有效载荷（即PipedInputStream缓冲区的大小）。但这并不会成为问题，因为主线程（main）很快就会从 
PipedInputStream的循环缓冲区读取数据，空出缓冲区空间。最终，写操作线程会从上一次中止的地方重新开始，写入2000字节有效载荷中的剩余部分。”
（联想多线程的情况，一个线程往管道流的缓存区写入大于1024字节的数据，当然在写入第1024个字节后该负责写入的线程会堵塞，因为缓存区写满了，
但是这个线程堵塞了main主线程（在代码中负责读取管道缓存区的数据）并没有堵塞，main线程迅速读取这些数据，空出管道缓存区的空间，则负责往管道
缓存区写入数据的线程就从阻塞态中释放出来了，可以继续写入数据，而这一整个过程由计算机处理非常迅速，表现出来的就好像一次性可以写入超过1024
个字节的数据。）

中午肝手游时候突然想到了之前自己看到的一篇关于字节字符输入输出流的博客：
其实输入输出流都可以理解成为是一种管道，里面放水的那种，所以是Stream，然后输入和输出流的实例对象其实都是一样的，只不过我们规定比如输入流
里面有read方法指定我们可以通过这个管子从我们构造这个管子时候所用的指定的对象中读取数据，输出则相反。

2、关于管道流的读取和写入出现IOException的情况
见博客好了 懒得复制粘贴了
那个沙雕代码老子是真的看不懂 :)     //LoopedStreams.java
